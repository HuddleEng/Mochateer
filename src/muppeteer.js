/**
 *
 * This file represents the Muppeteer interface. The initialize function exposes the final API that can be used
 * in test cases, including the native Puppeteer page object for cases where this API doesn't cover enough yet
 *
 *
 * Example usage:
 *
 *  Muppeteer({
 *              componentName,
 *              url: componentTestUrlFactory(component),
 *              visualPath: componentTestVisualPathFactory(component),
 *              visualThreshold,
 *              shouldRebaseVisuals,
 *              onLoad: component.onLoad
 *  });
 *
 *  componentName is the name of the component you want to test, but this could equally be a page name
 *  url is the url to be loaded by the browser when running the test, either a static one, or generated by a factory
 *  visualPath is the path to for visual tests to run in, either a static one, or generated by a factory
 *  visualThreshold is a value between 0 and 1 to present the threshold at which a visual test may pass or fail
 *  shouldRebaseVisuals is a flag to tell the visual regression engine to replace the existing baseline visuals
 *  onLoad is an optional object that can be passed in during a test to run a function on load. {fn, args}
 *
 **/

const addContext = require('mochawesome/addContext');
const {assert} = require('chai');
const {browserInstance} = require('../lib/test-controller');
const waits = require('./api/waits');
const keyboard = require('./api/keyboard');
const mouse = require('./api/mouse');
const retrieval = require('./api/retrieval');
const visual = require('./api/visual');
const miscellaneous = require('./api/miscellaneous');
const VisualRegression = require('./visual-regression');

const TIMEOUT_MS = 5000;

module.exports = function Muppeteer({
    componentName = 'unnamed-component',
    testId,
    url,
    visualThreshold = 0.05,
    visualPath,
    shouldRebaseVisuals,
    onLoad} = {}) {

    const state = {
        testId: testId || componentName,
        testContext: null,
        url,
        onLoad,
        visualThreshold,
        visualPath,
        shouldRebaseVisuals,
        resourceRequests: [],
        puppeteerPage: null,
        page: null,
        assert,
        resetRequests() {
            state.resourceRequests = [];
        },
        async finish() {
            return state.puppeteerPage.close();
        }
    };

    return {
        async initialize () {
            const browser = browserInstance.get();

            const createPageAPI = () => {
                const api = Object.assign({},
                    waits(state.puppeteerPage, state.resourceRequests, TIMEOUT_MS),
                    retrieval(state.puppeteerPage),
                    mouse(state.puppeteerPage),
                    keyboard(state.puppeteerPage),
                    visual(state.puppeteerPage),
                    miscellaneous(state.puppeteerPage)
                );

                /**
                 * Compare the current state of an element to the baseline
                 * @param {string} selector - Selector of the element to compare
                 */
                assert.visual = async function(selector) {
                    const buffer = await api.screenshot(selector);
                    let r = await state.visualRegression.compareVisual(buffer, state.testId);

                    if (r.passOrFail === 'fail' && r.diffScreenshot) {
                        addContext(state.testContext, r.diffScreenshot);
                    }

                    assert.equal(r.passOrFail, 'pass', `Visual failure for selector '${selector}' with an approximate ${r.misMatchPercentage}% mismatch.`);
                };

                return api;
            };

            state.puppeteerPage = await browser.newPage();
            state.page = createPageAPI();

            state.puppeteerPage.on('request', request => {
                state.resourceRequests.push(request);
            });

            // default viewport
            await state.puppeteerPage.setViewport({width: 900, height: 900, deviceScaleFactor: 1});
            await state.puppeteerPage.goto(state.url, { timeout: TIMEOUT_MS });

            if (state.onLoad && state.onLoad.fn) {
                const args = state.onLoad.args || [];
                await state.page.evaluate(state.onLoad.fn, ...args);
            }

            state.visualRegression = VisualRegression({
                page: state.puppeteerPage,
                path: state.visualPath,
                visualThreshold: state.visualThreshold,
                shouldRebaseVisuals: state.shouldRebaseVisuals
            });

            return state;
        }
    };
};

